package home_work_1;

public class Zad_2 {
    public static void main(String[] args) {
        int a = 8;
        int b = 2;

        int c = 5 + b / a;
        System.out.println("5 + 2 / 8 = " + c); // результат 5 т.к. 2/8 дает 0

        int d = (5 + b) / a;
        System.out.println("(5 + 2)/8 = "+ d); // скобки в приоритете 7/8 = 0

        int e = (5 + b++) / a;
        System.out.println("(5 + 2++)/8 = "+ e); // b++ добавляет 1 к b после выполнения операции сложения, получается выражение как в прошлом примере

        b = 2;
        int f = (5 + b++) / --a;
        System.out.println("(5 + 2++)/--8 = "+ f); // 1. получаем 7/7

        b = 2;
        a = 8;
        int g = (5 * b >> b++) / --a;
        System.out.println("(5 * 2 >> 2++)/--8 = "+ g); // 10 = 00001010 сдвиг на 2 знака получаем 00000010 = 2; 2/7=0

        b = 2;
        a = 8;
        int h = (5 + 7 > 20 ? 68 : 22 * 2 >> b++) / --a;
        // если 5+7 > 20 то h = 68, иначе h = 44>>2 / 7 ; 44>>2 = 00101100>>2 = 00001011 = 11; h = 11/7 = 1.
        System.out.println("(5 + 7 > 20 ? 68 : 22 * 2 >> 2++)/--8 = "+ h);

        b = 2;
        a = 8;
       // int i = (5 + 7 > 20 ? 68 >= 68 : 22 * 2 >> b++) / --a;
        // Оказалось что в этом операторе аргументы должны быть совместного типа, а int и boolean не совсем совместны
        // и программа в этом месте ломается
        System.out.println("(5 + 7 > 20 ? 68 >= 68 : 22 * 2 >> 2++)/--8 = "+ "не работает эта хрень таким образом");

        boolean k = 6 - 2 > 3 && 12 * 12 <= 119;    // 6-2 > 3 - true, 12*12(144)<= 119 - false. в операторе "и" оба значения должны быть true. результат false.
        System.out.println("6 - 2 > 3 && 12 * 12 <= 119 = " + k);


        boolean l = true;
        boolean m = false;
        boolean n = l && m; // в операторе "и" оба значения должны быть true. результат false.
        System.out.println("true && false = " + n);


    }
}
